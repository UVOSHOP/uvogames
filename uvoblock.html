<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UVOBLOCK - v1.1 by ADITdeveloper</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        :root {
            --board-bg: #1a1a2e;
            --cell-border: #333;
            --text-color: #e0e0e0;
            --neon-blue: #00ffff;
            --neon-pink: #ff00ff;
            --neon-green: #39ff14;
            --neon-red: #ff3333;
            --neon-gold: #ffd700;
            --neon-orange: #ff8c00;
            --color-red-block: Tomato;
            --color-blue-block: DeepSkyBlue;
            --color-green-block: MediumSeaGreen;
            --color-orange-block: OrangeRed;
            --color-purple-block: MediumPurple;
            --color-pink-block: HotPink;
            --color-gold-block: Gold;
            --color-lightslategray-block: LightSlateGray;

            --glow-strong-blue: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px var(--neon-blue), 0 0 20px var(--neon-blue), 0 0 25px var(--neon-blue);
            --glow-medium-pink: 0 0 3px #fff, 0 0 6px var(--neon-pink), 0 0 9px var(--neon-pink);
            --glow-gold: 0 0 5px #fff, 0 0 10px var(--neon-gold), 0 0 15px var(--neon-gold);
            --glow-green: 0 0 5px #fff, 0 0 10px var(--neon-green), 0 0 15px var(--neon-green);
            --glow-red: 0 0 5px #fff, 0 0 10px var(--neon-red), 0 0 15px var(--neon-red);
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        @keyframes subtleBackgroundGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        html, body {
            overflow: hidden; /* Mencegah scrolling */
            width: 100%;
            height: 100%;
        }

        body {
            font-family: var(--font-family);
            /* Latar belakang gradasi biru tua ke biru sedang */
            background: linear-gradient(135deg, #0A0C20, #1A2E40, #2C4B6B, #3D6A8E);
            background-size: 400% 400%;
            animation: subtleBackgroundGradient 25s ease infinite;
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Pindahkan konten ke atas */
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
        }

        .header-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 400px; /* Sesuaikan dengan lebar game-container */
            padding: 20px 0;
            position: relative; /* Untuk penempatan skor di tengah */
        }

        .score-display-main {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 3.5em; /* Ukuran font besar untuk skor utama */
            font-weight: bold;
            color: #fff; /* Warna putih untuk skor */
            text-shadow: 0 0 10px rgba(255,255,255,0.7); /* Efek cahaya */
            z-index: 1; /* Pastikan di atas elemen lain di header */
        }

        .highscore-icon-display {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 1.4em;
            font-weight: bold;
            color: var(--neon-gold); /* Warna emas/oranye untuk highscore */
            text-shadow: var(--glow-gold);
            z-index: 2; /* Di atas skor utama jika berdekatan */
        }
        .highscore-icon-display .fa-crown {
            color: var(--neon-gold);
            font-size: 1.2em;
        }

        .menu-icon-button {
            background: none;
            border: none;
            color: var(--neon-blue); /* Warna biru muda untuk ikon roda gigi */
            font-size: 2.2em; /* Ukuran ikon roda gigi */
            cursor: pointer;
            position: relative;
            text-shadow: var(--glow-strong-blue);
            z-index: 2; /* Di atas skor utama jika berdekatan */
            padding: 0; /* Hapus padding default button */
            line-height: 1; /* Pastikan ikon tidak terpotong */
        }
        .menu-icon-button:hover {
            transform: scale(1.1);
        }
        .menu-icon-button .notification-dot {
            position: absolute;
            top: 0px;
            right: 0px;
            width: 8px;
            height: 8px;
            background-color: var(--neon-red);
            border-radius: 50%;
            box-shadow: 0 0 5px var(--neon-red);
        }

        .game-wrapper { /* Wrapper untuk game dan menu */
            position: relative;
            width: fit-content; /* Agar menu bisa overlay dengan benar */
            margin-top: 20px; /* Jarak dari header */
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            background-color: rgba(10, 10, 20, 0.8);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            border: 1px solid var(--neon-blue);
            transition: filter 0.3s ease, pointer-events 0.3s ease; /* Untuk efek blur saat menu aktif */
        }
        .game-container.menu-active {
            filter: blur(3px);
            pointer-events: none; /* Nonaktifkan interaksi game saat menu aktif */
        }
        
        #game-board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            width: 360px; 
            height: 360px;
            background-color: var(--board-bg);
            border: 2px solid var(--neon-blue);
            box-shadow: inset 0 0 15px rgba(0, 255, 255, 0.4);
            position: relative;
        }

        .grid-cell {
            width: 40px;
            height: 40px;
            background-color: transparent;
            border: 1px solid var(--cell-border);
            box-sizing: border-box;
            transition: transform 0.2s ease, opacity 0.2s ease, background-color 0.2s ease, border-radius 0.2s ease; /* Transisi lebih halus */
            will-change: transform, opacity, background-color; /* Optimasi kinerja */
        }
        .grid-cell.clearing {
            transform: scale(0.1) rotate(180deg); /* Tambah rotasi */
            opacity: 0;
            background-color: var(--neon-gold) !important;
            border-radius: 50%; /* Jadi lingkaran saat hilang */
        }
        .grid-cell.placed-animation {
            animation: cellPlaceAnim 0.3s ease-out;
        }
        @keyframes cellPlaceAnim {
            0% { transform: scale(0.5); opacity: 0.5; }
            70% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .grid-cell.highlight {
            background-color: rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .grid-cell.shadow {
            background-color: rgba(0, 255, 255, 0.3); /* Neon blue shadow */
            opacity: 0.6;
            box-shadow: inset 0 0 8px rgba(0, 255, 255, 0.7);
        }

        .next-pieces-area {
            display: flex;
            justify-content: space-around;
            align-items: center;
            width: 100%;
            max-width: 370px;
            height: auto;
            padding: 8px;
            background-color: rgba(26, 26, 46, 0.6);
            border-radius: 10px;
            border: 1px solid var(--neon-blue);
            min-height: 90px;
        }

        .piece-container {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 110px; 
            height: 80px;
            animation: pieceAppearAnim 0.5s ease-out forwards;
            opacity: 0;
            will-change: transform, opacity; /* Optimasi kinerja */
        }
        @keyframes pieceAppearAnim {
            from { opacity: 0; transform: translateY(20px) scale(0.8); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .block {
            display: grid;
            position: absolute; 
            cursor: grab;
            will-change: transform, left, top; /* Optimasi kinerja */
        }
        .block.in-preview {
            position: relative;
            border: none;
        }
        
        .block.dragging {
            opacity: 0.75;
            transform: scale(1.1); 
            box-shadow: 0 8px 20px rgba(0,0,0,0.6);
            pointer-events: none; 
            z-index: 1100; /* Di atas menu saat drag */
        }
        .block.invalid-drop-feedback {
            animation: shakeBlock 0.3s ease-in-out;
        }
        @keyframes shakeBlock {
            0%, 100% { transform: translateX(0) scale(1.1); }
            25% { transform: translateX(-5px) scale(1.1); }
            75% { transform: translateX(5px) scale(1.1); }
        }

        .block-cell, .board-cell-styled {
            box-sizing: border-box;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 2px rgba(255,255,255,0.3), inset 0 0 5px rgba(0,0,0,0.2);
        }
        .block-cell {
            width: 18px;
            height: 18px;
        }
        
        .color-blue, .board-cell-blue { background: linear-gradient(135deg, var(--color-blue-block), #009acd); box-shadow: 0 0 4px var(--color-blue-block), inset 0 0 3px rgba(255,255,255,0.2); border-radius: 3px; }
        .color-red, .board-cell-red { background: linear-gradient(135deg, var(--color-red-block), #cc3300); box-shadow: 0 0 4px var(--color-red-block), inset 0 0 3px rgba(255,255,255,0.2); border-radius: 3px; }
        .color-green, .board-cell-green { background: linear-gradient(135deg, var(--color-green-block), #228B22); box-shadow: 0 0 4px var(--color-green-block), inset 0 0 3px rgba(255,255,255,0.2); border-radius: 3px; }
        .color-orange, .board-cell-orange { background: linear-gradient(135deg, var(--color-orange-block), #cc5500); box-shadow: 0 0 4px var(--color-orange-block), inset 0 0 3px rgba(255,255,255,0.2); border-radius: 3px; }
        .color-purple, .board-cell-purple { background: linear-gradient(135deg, var(--color-purple-block), #7A378B); box-shadow: 0 0 4px var(--color-purple-block), inset 0 0 3px rgba(255,255,255,0.2); border-radius: 3px; }
        .color-pink, .board-cell-pink { background: linear-gradient(135deg, var(--color-pink-block), #cc147a); box-shadow: 0 0 4px var(--color-pink-block), inset 0 0 3px rgba(255,255,255,0.2); border-radius: 3px; }
        .color-gold, .board-cell-gold { background: linear-gradient(135deg, var(--color-gold-block), #D4AF37); box-shadow: 0 0 4px var(--color-gold-block), inset 0 0 3px rgba(255,255,255,0.2); border-radius: 3px; }
        .color-lightslategray, .board-cell-lightslategray { background: linear-gradient(135deg, var(--color-lightslategray-block), #5c677d); box-shadow: 0 0 4px var(--color-lightslategray-block), inset 0 0 3px rgba(255,255,255,0.2); border-radius: 3px; }

        .game-over-message {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.7);
            background-color: rgba(0,0,0,0.85);
            padding: 30px 40px; border-radius: 10px;
            text-align: center; font-size: 2.2em; color: #ff4d4d; 
            z-index: 1001; 
            border: 2px solid var(--neon-pink);
            box-shadow: var(--glow-strong-blue);
            animation: gameOverAppear 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
        }
        @keyframes gameOverAppear { to { transform: translate(-50%, -50%) scale(1); } }

        .floating-text {
            position: absolute; font-size: 1.8em; font-weight: bold;
            pointer-events: none; z-index: 500; text-shadow: 0 0 5px black;
            animation: floatUpFadeOut 1.8s ease-out forwards;
            will-change: transform, opacity; /* Optimasi kinerja */
        }
        @keyframes floatUpFadeOut {
            0% { transform: translateY(0) scale(0.8); opacity: 1; }
            100% { transform: translateY(-70px) scale(1.2); opacity: 0; }
        }
        .floating-text.code-success { color: var(--neon-green); font-size: 2em !important; }
        .floating-text.code-fail { color: var(--neon-red); font-size: 1.5em !important; }
        
        .combo-text { color: var(--neon-blue); text-shadow: var(--glow-strong-blue); animation: floatUpFadeOut 1.8s ease-out forwards, pulseAndShake 0.6s infinite alternate; }
        @keyframes pulseAndShake { 
            0% { transform: scale(1.1) translateY(0) translateX(0); } 25% { transform: translateX(-3px); }
            50% { transform: scale(1.2) translateY(0) translateX(0); } 75% { transform: translateX(3px); }
            100% { transform: scale(1.1) translateY(0) translateX(0); }
        }
        .ampalibaba-text { color: var(--neon-green); font-size: 2.5em !important; text-shadow: 0 0 5px #000, 0 0 10px var(--neon-green), 0 0 15px var(--neon-green); animation: floatUpFadeOut 2s ease-out forwards, scaleUpBig 0.5s ease-out forwards; }
        @keyframes scaleUpBig { from { transform: scale(0.5); opacity: 0.5; } to { transform: scale(1); opacity: 1; } }
        .boom-text { color: var(--neon-orange); font-size: 3em !important; text-shadow: 0 0 5px #000, 0 0 10px var(--neon-orange), 0 0 15px var(--neon-orange); animation: floatUpFadeOut 2.2s ease-out forwards, boomTextAnim 0.6s ease-out; }
        @keyframes boomTextAnim { 0% { transform: scale(0.8) rotate(0deg); } 25% { transform: scale(1.2) rotate(-5deg); } 50% { transform: scale(1.1) rotate(5deg); } 75% { transform: scale(1.3) rotate(-2deg); } 100% { transform: scale(1.2) rotate(0deg); } }
        .perfect-clear-text { color: Gold; font-size: 2.8em !important; text-shadow: 0 0 5px #000, 0 0 10px Gold, 0 0 15px Gold, 0 0 20px Gold; animation: floatUpFadeOut 2.5s ease-out forwards, sparkle 1s infinite; }
        @keyframes sparkle { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.7; transform: scale(1.1); } }
        .backtoback-text { color: var(--neon-pink); font-size: 2.2em !important; text-shadow: 0 0 5px #000, 0 0 10px var(--neon-pink), 0 0 15px var(--neon-pink); animation: floatUpFadeOut 2s ease-out forwards, blinkFast 0.3s infinite; }
        @keyframes blinkFast { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

        .board-shake-subtle { animation: boardShakeSubtleAnim 0.3s ease-in-out; }
        @keyframes boardShakeSubtleAnim { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-4px); } 75% { transform: translateX(4px); } }
        .board-shake-strong { animation: boardShakeStrongAnim 0.4s ease-in-out; }
        @keyframes boardShakeStrongAnim { 0%, 100% { transform: translate(0, 0); } 20% { transform: translate(-6px, -3px) rotate(-1deg); } 40% { transform: translate(6px, 3px) rotate(1deg); } 60% { transform: translate(-4px, -2px) rotate(0.5deg); } 80% { transform: translate(4px, 2px) rotate(-0.5deg); } }
        
        /* --- Menu Overlay Styles --- */
        #menu-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(10, 10, 30, 0.85); /* Dark semi-transparent */
            backdrop-filter: blur(5px); /* Blur effect */
            -webkit-backdrop-filter: blur(5px); /* For Safari */
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000; /* On top of game */
            padding: 20px;
            box-sizing: border-box;
            animation: fadeInMenu 0.3s ease-out;
        }
        @keyframes fadeInMenu { from { opacity: 0; } to { opacity: 1; } }

        .menu-content {
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .menu-title {
            font-size: 3em;
            font-weight: bold;
            color: var(--neon-gold);
            text-shadow: var(--glow-gold), 0 0 2px black;
            line-height: 1.2;
            margin-bottom: 10px;
        }
        .menu-subtitle {
            font-size: 1.2em;
            color: var(--neon-blue);
            text-shadow: 0 0 5px var(--neon-blue);
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 250px; /* Fixed width for buttons */
            margin: 0 auto;
        }

        .menu-button {
            padding: 12px 20px;
            font-size: 1.2em;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, background-color 0.2s;
            color: white;
            text-shadow: 0 0 3px black;
        }
        .menu-button:hover { transform: scale(1.05); }
        .menu-button-resume { background-color: var(--neon-green); box-shadow: var(--glow-green); }
        .menu-button-resume:hover { background-color: #4cff33; } /* Brighter green */
        .menu-button-redeem { background-color: var(--neon-blue); box-shadow: var(--glow-strong-blue); }
        .menu-button-redeem:hover { background-color: #33ffff; } /* Brighter blue */
        .menu-button-reset { background-color: var(--neon-red); box-shadow: var(--glow-red); }
        .menu-button-reset:hover { background-color: #ff6666; } /* Brighter red */
        .menu-button-back { background-color: #777; box-shadow: 0 0 5px #aaa; }
        .menu-button-back:hover { background-color: #999; }

        /* --- Redeem Code Modal Styles --- */
        #redeem-modal {
            position: fixed; /* Fixed position to overlay everything */
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background-color: rgba(30, 30, 50, 0.95);
            padding: 30px;
            border-radius: 10px;
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 20px var(--neon-blue);
            z-index: 1002; /* Above menu overlay */
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 90%;
            max-width: 350px;
            animation: modalAppear 0.3s ease-out forwards;
        }
        @keyframes modalAppear {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.7); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        #redeem-modal h3 {
            color: var(--neon-gold);
            text-shadow: var(--glow-gold);
            margin-top: 0;
            font-size: 1.5em;
        }
        #redeem-code-input {
            padding: 10px;
            border-radius: 5px;
            border: 1px solid var(--neon-blue);
            background-color: #1a1a2e;
            color: var(--text-color);
            font-size: 1.1em;
            width: calc(100% - 22px); /* Full width minus padding/border */
            text-align: center;
        }
        .redeem-modal-buttons {
            display: flex;
            gap: 10px;
            width: 100%;
        }
        .redeem-modal-buttons button {
            flex-grow: 1;
            padding: 10px;
            font-size: 1em;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        #redeem-submit-button { background-color: var(--neon-green); color: #1a1a2e; }
        #redeem-submit-button:hover { background-color: #4cff33; }
        #redeem-close-button { background-color: #777; color: white; }
        #redeem-close-button:hover { background-color: #999; }


        /* Responsiveness */
        @media (max-width: 480px) {
            body { padding: 5px; }
            .header-section { max-width: 310px; padding: 15px 0;}
            .score-display-main { font-size: 2.8em; }
            .highscore-icon-display { font-size: 1.2em; }
            .menu-icon-button { font-size: 1.8em; }
            .menu-icon-button .notification-dot { top: 0px; right: 0px; width: 7px; height: 7px; }

            .game-wrapper { width: 100%; margin-top: 15px;}
            .game-container { padding: 10px; gap: 10px;}
            #game-board { width: 306px; height: 306px; }
            .grid-cell { width: 34px; height: 34px; }
            .block-cell { width: 14px; height: 14px; }
            .next-pieces-area { max-width: 310px; min-height: 70px; padding: 5px;}
            .piece-container { width: 90px; height: 65px; }
            .floating-text { font-size: 1.5em; }
            .ampalibaba-text { font-size: 2em !important; }
            .boom-text { font-size: 2.5em !important; }
            .perfect-clear-text { font-size: 2.2em !important; }
            .backtoback-text { font-size: 1.8em !important; }

            .menu-title { font-size: 2.2em; }
            .menu-subtitle { font-size: 1em; }
            .menu-buttons { width: 200px; }
            .menu-button { font-size: 1em; padding: 10px 15px; }

            #redeem-modal { padding: 20px; gap: 15px; }
            #redeem-modal h3 { font-size: 1.3em; }
            #redeem-code-input { font-size: 1em; }
        }
    </style>
</head>
<body>
    <div class="header-section">
        <div class="highscore-icon-display">
            <i class="fas fa-crown"></i> <span id="highscore">0</span>
        </div>
        <div class="score-display-main" id="score">0</div> <button class="menu-icon-button" id="menu-button">
            <i class="fas fa-cog"></i> <span class="notification-dot"></span> </button>
    </div>

    <div class="game-wrapper">
        <div class="game-container" id="game-main-container">
            <div id="game-board"></div>

            <div class="next-pieces-area">
                <div class="piece-container" id="piece-container-0"></div>
                <div class="piece-container" id="piece-container-1"></div>
                <div class="piece-container" id="piece-container-2"></div>
            </div>

            <div id="game-over-message" class="game-over-message" style="display: none;">
                Game Over!
                <button id="restart-game-over" style="margin-top:15px; padding: 10px 15px; font-size: 0.7em; background-color: var(--neon-blue); color: #1a1a2e; border:none; border-radius:5px; cursor:pointer;">Main Lagi</button>
            </div>
        </div>

        <div id="menu-overlay">
            <div class="menu-content">
                <div>
                    <div class="menu-title">UVOBLOCK</div>
                    <div class="menu-subtitle">versi 1.1 by ADITdeveloper</div>
                </div>
                <div class="menu-buttons">
                    <button class="menu-button menu-button-resume" id="resume-game-button">Kembali ke Game</button>
                    <button class="menu-button menu-button-redeem" id="open-redeem-button">Redeem Code</button>
                    <button class="menu-button menu-button-reset" id="reset-score-button">Reset Score</button>
                    <button class="menu-button menu-button-back" id="back-to-main-menu-button">Kembali ke Menu</button>
                </div>
            </div>
        </div>

        <div id="redeem-modal">
            <h3>Masukkan Kode Bonus</h3>
            <input type="text" id="redeem-code-input" placeholder="XXXXX">
            <div class="redeem-modal-buttons">
                <button id="redeem-submit-button">Submit</button>
                <button id="redeem-close-button">Tutup</button>
            </div>
        </div>
    </div>

    <script>
        // --- KONSTANTA DAN KONFIGURASI GAME ---
        const GRID_SIZE = 9;
        const CELL_SIZE_BOARD_CSS = 40;
        const CELL_SIZE_PREVIEW = 18;
        const REDEEM_CODES = {
            "55555": 3000,
            "12345": 1000,
            "151515": 10000,
            "54321": 2000
        };

        const BLOCK_DEFINITIONS = [ 
            { name: 'Square1x1', cells: [[0,0]], color: 'pink', idColor: 'board-cell-pink' },
            { name: 'Line1x4', cells: [[0,0], [0,1], [0,2], [0,3]], color: 'blue', idColor: 'board-cell-blue' },
            { name: 'Line4x1', cells: [[0,0], [1,0], [2,0], [3,0]], color: 'blue', idColor: 'board-cell-blue' },
            { name: 'LShape1', cells: [[0,0], [1,0], [1,1]], color: 'red', idColor: 'board-cell-red' },
            { name: 'LShape2', cells: [[0,1], [1,1], [1,0]], color: 'red', idColor: 'board-cell-red' },
            { name: 'TShape1', cells: [[0,1],[1,0],[1,1],[1,2]], color: 'green', idColor: 'board-cell-green' },
            { name: 'ZShape1', cells: [[0,0],[0,1],[1,1],[1,2]], color: 'orange', idColor: 'board-cell-orange' },
            { name: 'SShape1', cells: [[1,0],[1,1],[0,1],[0,2]], color: 'purple', idColor: 'board-cell-purple' },
            { name: 'PlusShape', cells: [[0,1],[1,0],[1,1],[1,2],[2,1]], color: 'gold', idColor: 'board-cell-gold' },
            { name: 'Square2x2', cells: [[0,0],[0,1],[1,0],[1,1]], color: 'gold', idColor: 'board-cell-gold' },
            { name: 'Square3x3', cells: [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]], color: 'lightslategray', idColor: 'board-cell-lightslategray' }
        ];

        // --- VARIABEL GAME STATE ---
        let boardState = []; 
        let currentScore = 0;
        let highScore = 0;
        let currentPieces = [null, null, null];
        let draggedPiece = null;
        let piecePlacedCount = 0;
        let comboCount = 0;
        let lastMajorEffect = null;
        let scoreAnimationInterval;
        let isMenuOpen = false;
        let currentShadowCells = []; // To track shadow cells

        // --- ELEMEN DOM ---
        const gameMainContainer = document.getElementById('game-main-container');
        const gameBoardElement = document.getElementById('game-board');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highscore');
        const nextPieceContainers = [
            document.getElementById('piece-container-0'),
            document.getElementById('piece-container-1'),
            document.getElementById('piece-container-2')
        ];
        const gameOverMessageElement = document.getElementById('game-over-message');
        const restartGameOverButton = document.getElementById('restart-game-over');

        // Menu Elements
        const menuButton = document.getElementById('menu-button');
        const menuOverlay = document.getElementById('menu-overlay');
        const resumeGameButton = document.getElementById('resume-game-button');
        const openRedeemButton = document.getElementById('open-redeem-button');
        const resetScoreButton = document.getElementById('reset-score-button');
        const backToMainMenuButton = document.getElementById('back-to-main-menu-button');

        // Redeem Modal Elements
        const redeemModal = document.getElementById('redeem-modal');
        const redeemCodeInput = document.getElementById('redeem-code-input');
        const redeemSubmitButton = document.getElementById('redeem-submit-button');
        const redeemCloseButton = document.getElementById('redeem-close-button');


        // --- FUNGSI INISIASI GAME ---
        function initGame(isRestartFromMenu = false) {
            boardState = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));
            gameBoardElement.innerHTML = '';
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    gameBoardElement.appendChild(cell);
                }
            }
            if (!isRestartFromMenu) { 
                 currentScore = 0;
            }
            animateScoreUpdate(currentScore);
            loadHighScore();
            gameOverMessageElement.style.display = 'none';
            nextPieceContainers.forEach(container => container.innerHTML = '');
            generateNewPiecesSet();
            piecePlacedCount = 0;
            comboCount = 0;
            lastMajorEffect = null;
            gameBoardElement.classList.remove('board-shake-subtle', 'board-shake-strong');
            closeMenu(); 
        }

        // --- MENU FUNCTIONS ---
        function openMenu() {
            isMenuOpen = true;
            menuOverlay.style.display = 'flex';
            gameMainContainer.classList.add('menu-active');
        }

        function closeMenu() {
            isMenuOpen = false;
            menuOverlay.style.display = 'none';
            gameMainContainer.classList.remove('menu-active');
            redeemModal.style.display = 'none';
        }

        menuButton.addEventListener('click', openMenu);
        resumeGameButton.addEventListener('click', closeMenu);

        resetScoreButton.addEventListener('click', () => {
            if (confirm("Apakah kamu yakin ingin menghapus skor dan skor tertinggi? Tindakan ini tidak bisa dibatalkan.")) {
                highScore = 0;
                currentScore = 0; 
                saveHighScore();
                highScoreElement.textContent = highScore;
                animateScoreUpdate(currentScore); 
                const feedbackText = document.createElement('div');
                feedbackText.textContent = "Skor Direset!";
                feedbackText.style.color = "var(--neon-red)";
                feedbackText.style.textAlign = "center";
                feedbackText.style.marginTop = "10px";
                feedbackText.style.fontSize = "0.9em";
                resetScoreButton.parentElement.appendChild(feedbackText);
                setTimeout(() => feedbackText.remove(), 2000);
            }
        });

        backToMainMenuButton.addEventListener('click', () => {
            if (history.length > 1) {
                history.back();
            } else {
                alert("Tidak ada halaman sebelumnya di histori.");
            }
        });
        
        // --- REDEEM CODE FUNCTIONS ---
        openRedeemButton.addEventListener('click', () => {
            redeemModal.style.display = 'flex';
            redeemCodeInput.value = ''; 
            redeemCodeInput.focus();
        });

        redeemCloseButton.addEventListener('click', () => {
            redeemModal.style.display = 'none';
        });

        redeemSubmitButton.addEventListener('click', () => {
            const code = redeemCodeInput.value.trim().toUpperCase(); 
            if (REDEEM_CODES.hasOwnProperty(code)) {
                const scoreBonus = REDEEM_CODES[code];
                currentScore += scoreBonus;
                animateScoreUpdate(currentScore);
                showFloatingText(`+${scoreBonus} Skor!`, Math.floor(GRID_SIZE / 2) - 2, Math.floor(GRID_SIZE / 2) - 1, 'code-success');
                delete REDEEM_CODES[code]; 
                redeemModal.style.display = 'none';
            } else {
                showFloatingText("Kode Invalid!", Math.floor(GRID_SIZE / 2) - 2, Math.floor(GRID_SIZE / 2) - 1, 'code-fail');
                redeemCodeInput.style.animation = "shakeBlock 0.3s";
                setTimeout(() => redeemCodeInput.style.animation = "", 300);
            }
        });


        // --- FUNGSI RENDER ---
        function renderBoard() {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cellElement = gameBoardElement.children[r * GRID_SIZE + c];
                    cellElement.className = 'grid-cell'; 
                    if (boardState[r][c] !== 0) {
                        cellElement.classList.add('filled', boardState[r][c]); 
                    }
                }
            }
            clearShadow(); 
        }

        function createBlockElement(blockDef, isPreview = false) {
            const blockElement = document.createElement('div');
            blockElement.classList.add('block');
            if(isPreview) blockElement.classList.add('in-preview');
            
            let minR = 0, maxR = 0, minC = 0, maxC = 0;
            blockDef.cells.forEach(([r, c]) => {
                minR = Math.min(minR, r); maxR = Math.max(maxR, r);
                minC = Math.min(minC, c); maxC = Math.max(maxC, c);
            });
            const rows = maxR - minR + 1;
            const cols = maxC - minC + 1;

            blockElement.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
            blockElement.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            
            const actualBoardCellSize = gameBoardElement.querySelector('.grid-cell')?.offsetWidth || CELL_SIZE_BOARD_CSS;
            const cellSizeForBlock = isPreview ? CELL_SIZE_PREVIEW : actualBoardCellSize;

            blockElement.style.width = `${cols * cellSizeForBlock}px`;
            blockElement.style.height = `${rows * cellSizeForBlock}px`;

            blockDef.cells.forEach(([r, c]) => {
                const cell = document.createElement('div');
                cell.classList.add(`color-${blockDef.color}`); 
                if (isPreview) cell.classList.add('block-cell'); 
                
                cell.style.gridRowStart = r - minR + 1;
                cell.style.gridColumnStart = c - minC + 1;
                
                cell.style.width = `${cellSizeForBlock}px`;
                cell.style.height = `${cellSizeForBlock}px`;
                blockElement.appendChild(cell);
            });
            blockElement.dataset.blockName = blockDef.name;
            return blockElement;
        }
        
        function generateNewPiecesSet() {
            for (let i = 0; i < 3; i++) {
                const randomDef = BLOCK_DEFINITIONS[Math.floor(Math.random() * BLOCK_DEFINITIONS.length)];
                const blockDefCopy = JSON.parse(JSON.stringify(randomDef)); 
                currentPieces[i] = { def: blockDefCopy, element: null, placed: false };
                
                const blockElement = createBlockElement(blockDefCopy, true);
                currentPieces[i].element = blockElement;
                
                nextPieceContainers[i].innerHTML = ''; 
                nextPieceContainers[i].appendChild(blockElement);
                
                const parentContainer = nextPieceContainers[i];
                parentContainer.classList.remove('pieceAppearAnim');
                void parentContainer.offsetWidth; 
                parentContainer.style.animationDelay = `${i * 0.1}s`;
                parentContainer.classList.add('pieceAppearAnim');
                
                blockElement.addEventListener('pointerdown', (e) => { if (!isMenuOpen) handlePreviewDragStart(e, i); });
            }
            piecePlacedCount = 0;
        }

        // --- FUNGSI DRAG & DROP ---
        let dragOffsetX, dragOffsetY;

        function handlePreviewDragStart(event, pieceIndex) {
            if (isMenuOpen || currentPieces[pieceIndex].placed || draggedPiece) return; 
            
            const blockDef = currentPieces[pieceIndex].def;
            const previewElement = currentPieces[pieceIndex].element;

            const activeBlockElement = createBlockElement(blockDef, false);
            document.body.appendChild(activeBlockElement); 
            activeBlockElement.classList.add('dragging');
            
            const previewRect = previewElement.getBoundingClientRect();
            dragOffsetX = event.clientX - previewRect.left;
            dragOffsetY = event.clientY - previewRect.top;
            
            activeBlockElement.style.left = `${event.clientX - dragOffsetX}px`;
            activeBlockElement.style.top = `${event.clientY - dragOffsetY}px`;

            draggedPiece = {
                blockDef: blockDef,
                element: activeBlockElement,
                originalParent: nextPieceContainers[pieceIndex],
                originalElement: previewElement,
                pieceIndex: pieceIndex
            };
            previewElement.style.opacity = '0.3';
            document.addEventListener('pointermove', handleDrag);
            document.addEventListener('pointerup', handleDrop);
        }
        
        function handleDrag(event) {
            if (!draggedPiece) return;
            event.preventDefault();
            draggedPiece.element.style.left = `${event.clientX - dragOffsetX}px`;
            draggedPiece.element.style.top = `${event.clientY - dragOffsetY}px`;

            updateShadow(event.clientX, event.clientY, draggedPiece.blockDef);
        }

        function handleDrop(event) {
            if (!draggedPiece) return;
            
            const draggedElement = draggedPiece.element;
            const boardRect = gameBoardElement.getBoundingClientRect();
            const boardCellActualSize = gameBoardElement.querySelector('.grid-cell').offsetWidth;

            const dropX = event.clientX - boardRect.left;
            const dropY = event.clientY - boardRect.top;

            const targetCol = Math.floor(dropX / boardCellActualSize);
            const targetRow = Math.floor(dropY / boardCellActualSize);
            
            if (isValidPlacement(draggedPiece.blockDef, targetRow, targetCol)) {
                placeBlockOnBoard(draggedPiece.blockDef, targetRow, targetCol);
                currentPieces[draggedPiece.pieceIndex].placed = true;
                draggedPiece.originalParent.innerHTML = ''; 
                piecePlacedCount++;
                checkForClearsAndAnimate(targetRow, targetCol);
            } else {
                draggedElement.classList.add('invalid-drop-feedback');
                draggedElement.addEventListener('animationend', () => {
                    draggedElement.remove(); 
                    draggedPiece.originalElement.style.opacity = '1'; 
                    draggedPiece = null;
                }, { once: true });
            }
            clearShadow();
            document.removeEventListener('pointermove', handleDrag);
            document.removeEventListener('pointerup', handleDrop);
        }

        function updateShadow(clientX, clientY, blockDef) {
            clearShadow(); 

            const boardRect = gameBoardElement.getBoundingClientRect();
            const boardCellActualSize = gameBoardElement.querySelector('.grid-cell').offsetWidth;

            const relativeX = clientX - boardRect.left;
            const relativeY = clientY - boardRect.top;

            const targetCol = Math.floor(relativeX / boardCellActualSize);
            const targetRow = Math.floor(relativeY / boardCellActualSize);

            const cellsForShadow = [];
            let canPlaceShadow = true;
            for (const [rOffset, cOffset] of blockDef.cells) {
                const r = targetRow + rOffset;
                const c = targetCol + cOffset;
                if (r < 0 || r >= GRID_SIZE || c < 0 || c >= GRID_SIZE || boardState[r][c] !== 0) {
                    canPlaceShadow = false;
                    break;
                }
                cellsForShadow.push({r, c});
            }

            if (canPlaceShadow) {
                currentShadowCells = cellsForShadow;
                currentShadowCells.forEach(({r, c}) => {
                    const cellElement = gameBoardElement.children[r * GRID_SIZE + c];
                    if (cellElement && boardState[r][c] === 0) { 
                        cellElement.classList.add('shadow');
                    }
                });
            }
        }

        function clearShadow() {
            currentShadowCells.forEach(({r, c}) => {
                const cellElement = gameBoardElement.children[r * GRID_SIZE + c];
                if (cellElement) {
                    cellElement.classList.remove('shadow');
                }
            });
            currentShadowCells = [];
        }
        
        function postClearActions(linesClearedCount, baseRow, baseCol) {
            let currentMajorEffect = null;
            if (linesClearedCount > 0) {
                gameBoardElement.classList.add('board-shake-subtle');
                setTimeout(() => gameBoardElement.classList.remove('board-shake-subtle'), 300);

                let effectText = ""; let effectClass = ""; let scoreBonus = 0;

                if (linesClearedCount >= 5) { 
                    effectText = "Boom!"; effectClass = 'boom-text'; scoreBonus += 300; currentMajorEffect = 'boom';
                    gameBoardElement.classList.add('board-shake-strong');
                    setTimeout(() => gameBoardElement.classList.remove('board-shake-strong'), 400);
                } else if (linesClearedCount >= 3) { 
                    effectText = "AmPalibaba!"; effectClass = 'ampalibaba-text'; scoreBonus += 200; currentMajorEffect = 'ampalibaba';
                }

                if (lastMajorEffect && currentMajorEffect && (lastMajorEffect === 'ampalibaba' || lastMajorEffect === 'boom') && (currentMajorEffect === 'ampalibaba' || currentMajorEffect === 'boom') ) {
                    showFloatingText("Back-to-Back!", baseRow -1 < 0 ? 0 : baseRow -1, baseCol, 'backtoback-text');
                    scoreBonus += 150; 
                }
                lastMajorEffect = currentMajorEffect || (linesClearedCount > 0 ? 'clear' : null); 


                if (comboCount > 0 && linesClearedCount > 0) {
                    showFloatingText(`Combo x${comboCount + 1}!`, baseRow, baseCol, 'combo-text');
                    currentScore += (50 * linesClearedCount * (comboCount + 1));
                } else if (linesClearedCount > 0) {
                     currentScore += (50 * linesClearedCount); 
                }
                comboCount = linesClearedCount > 0 ? comboCount + 1 : 0;
                
                if (effectText) showFloatingText(effectText, baseRow, baseCol, effectClass);
                currentScore += scoreBonus;

                if (isBoardEmpty()) {
                    showFloatingText("Perfect Clear!", Math.floor(GRID_SIZE/2)-1, Math.floor(GRID_SIZE/2)-1, 'perfect-clear-text');
                    currentScore += 500;
                    lastMajorEffect = 'perfect'; 
                }
            } else { 
                comboCount = 0;
                if (lastMajorEffect !== 'boom' && lastMajorEffect !== 'ampalibaba' && lastMajorEffect !== 'perfect') { 
                    lastMajorEffect = null;
                }
            }
            animateScoreUpdate(currentScore); 
            renderBoard(); 

            if (draggedPiece && draggedPiece.element.parentNode) { 
                draggedPiece.element.remove();
            }
            draggedPiece = null; 

            if (piecePlacedCount === 3) {
                setTimeout(generateNewPiecesSet, 200); 
            }

            if (checkGameOver()) {
                showGameOver();
            }
        }

        function isValidPlacement(blockDef, baseRow, baseCol) {
            for (const [rOffset, cOffset] of blockDef.cells) {
                const r = baseRow + rOffset;
                const c = baseCol + cOffset;
                if (r < 0 || r >= GRID_SIZE || c < 0 || c >= GRID_SIZE || boardState[r][c] !== 0) {
                    return false; 
                }
            }
            return true;
        }

        function placeBlockOnBoard(blockDef, baseRow, baseCol) {
            let cellsFilled = 0;
            blockDef.cells.forEach(([rOffset, cOffset]) => {
                const r = baseRow + rOffset;
                const c = baseCol + cOffset;
                if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE) {
                    boardState[r][c] = blockDef.idColor; 
                    cellsFilled++;
                    const cellElement = gameBoardElement.children[r * GRID_SIZE + c];
                    cellElement.classList.add('placed-animation', blockDef.idColor); 
                    cellElement.addEventListener('animationend', () => cellElement.classList.remove('placed-animation'), { once: true });
                }
            });
            currentScore += cellsFilled * 10; 
        }

        // --- FUNGSI LOGIKA GAME ---
        function checkForClearsAndAnimate(placedRow, placedCol) {
            let rowsToClear = []; let colsToClear = []; let clearedCellsCoords = [];
            for (let r = 0; r < GRID_SIZE; r++) { if (boardState[r].every(cell => cell !== 0)) rowsToClear.push(r); }
            for (let c = 0; c < GRID_SIZE; c++) { if (boardState.every(row => row[c] !== 0)) colsToClear.push(c); }
            
            let distinctLineEntities = new Set([...rowsToClear.map(r => `R${r}`), ...colsToClear.map(c => `C${c}`)]);
            let linesClearedCount = distinctLineEntities.size;

            let uniqueCellsToClear = new Set();
            rowsToClear.forEach(r => { for (let c = 0; c < GRID_SIZE; c++) uniqueCellsToClear.add(`${r}-${c}`); });
            colsToClear.forEach(c => { for (let r = 0; r < GRID_SIZE; r++) uniqueCellsToClear.add(`${r}-${c}`); });
            
            let animationPromises = [];

            uniqueCellsToClear.forEach(coordStr => {
                const [r, c] = coordStr.split('-').map(Number);
                clearedCellsCoords.push({r, c});
                const cellElement = gameBoardElement.children[r * GRID_SIZE + c];
                cellElement.classList.add('clearing');
                animationPromises.push(new Promise(resolve => cellElement.addEventListener('transitionend', resolve, { once: true }) ));
            });

            if (animationPromises.length > 0) {
                Promise.all(animationPromises).then(() => {
                    clearedCellsCoords.forEach(({r, c}) => boardState[r][c] = 0);
                    postClearActions(linesClearedCount, placedRow, placedCol);
                });
            } else { 
                postClearActions(0, placedRow, placedCol); 
            }
        }
        
        function isBoardEmpty() { return boardState.every(row => row.every(cell => cell === 0)); }

        function checkGameOver() {
            for (let i = 0; i < currentPieces.length; i++) {
                if (!currentPieces[i] || currentPieces[i].placed) {
                    continue; 
                }
                const blockDef = currentPieces[i].def;
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        if (isValidPlacement(blockDef, r, c)) {
                            return false; 
                        }
                    }
                }
            }
            return currentPieces.some(p => p && !p.placed); 
        }

        function showGameOver() {
            gameOverMessageElement.style.display = 'block';
            if (currentScore > highScore) {
                highScore = currentScore;
                saveHighScore();
            }
            highScoreElement.textContent = highScore;
        }

        // --- FUNGSI SKOR & UI ---
        function animateScoreUpdate(targetScore) {
            clearInterval(scoreAnimationInterval);
            let currentDisplayScore = parseInt(scoreElement.textContent);
            if (isNaN(currentDisplayScore)) currentDisplayScore = 0;
            const diff = targetScore - currentDisplayScore;
            if (diff === 0) { scoreElement.textContent = targetScore; return; }
            const duration = 300; const steps = 20;
            const stepValue = diff / steps; let stepCount = 0;
            scoreAnimationInterval = setInterval(() => {
                currentDisplayScore += stepValue; stepCount++;
                scoreElement.textContent = Math.round(currentDisplayScore);
                if (stepCount >= steps) {
                    clearInterval(scoreAnimationInterval);
                    scoreElement.textContent = targetScore; 
                }
            }, duration / steps);
        }

        function saveHighScore() { try { localStorage.setItem('uvoblock_v1.1_highscore', highScore); } catch (e) { console.error("Gagal simpan skor:", e); } }
        function loadHighScore() { try { const saved = localStorage.getItem('uvoblock_v1.1_highscore'); highScore = saved ? parseInt(saved, 10) : 0; } catch (e) { console.error("Gagal muat skor:", e); highScore = 0; } highScoreElement.textContent = highScore; }
        
        function showFloatingText(text, boardRow, boardCol, ...extraClasses) {
            const textElement = document.createElement('div');
            textElement.classList.add('floating-text', ...extraClasses);
            textElement.textContent = text;
            const boardCellActualSize = gameBoardElement.querySelector('.grid-cell')?.offsetWidth || CELL_SIZE_BOARD_CSS;
            let textLeft = (gameBoardElement.offsetWidth / 2) - (textElement.offsetWidth / 2);
            let textTop = (gameBoardElement.offsetHeight / 2) - 30; 

            if (boardRow !== undefined && boardCol !== undefined) {
                textLeft = boardCol * boardCellActualSize + (boardCellActualSize / 2) - (textElement.offsetWidth / 2);
                textTop = boardRow * boardCellActualSize - 20; 
                textLeft = Math.max(0, Math.min(textLeft, gameBoardElement.offsetWidth - 60)); 
            }
            
            textElement.style.left = `${textLeft}px`; 
            textElement.style.top = `${textTop}px`; 
            gameBoardElement.appendChild(textElement); 
            textElement.addEventListener('animationend', () => { if (textElement.parentNode) textElement.remove(); }, { once: true });
        }

        // --- EVENT LISTENERS ---
        restartGameOverButton.addEventListener('click', () => initGame(false)); 
        
        // --- MULAI GAME ---
        initGame(false);

    </script>
</body>
</html>
