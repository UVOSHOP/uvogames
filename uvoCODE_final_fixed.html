<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport"/>
<title>UVOBLOCK - Puzzle Pecah Blok</title>
<link href="https://fonts.googleapis.com/css2?family=Bangers&amp;family=Press+Start2P&amp;display=swap" rel="stylesheet"/>
<style>
        /* CSS RESET */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none; /* Prevents default touch actions like scrolling */
        }

        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #4A90E2; /* Inspired by image blue */
            font-family: 'Press Start 2P', cursive;
            color: #ecf0f1;
            overscroll-behavior: none; /* Prevents pull-to-refresh */
            transition: background-color 1s ease-in-out;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #3B82C9; /* Slightly darker blue for container */
            border: none;
            box-shadow: none;
            padding: 20px;
            border-radius: 12px;
            position: relative;
            max-width: 95vw;
            max-height: 98vh;
            aspect-ratio: 1 / 1.6; /* Default, good for portrait */
            overflow: hidden;
            flex-grow: 1; /* Allow container to grow */
            justify-content: space-between; /* Distribute content vertically */
        }

        /* Orientasi Landscape untuk HP */
        @media (orientation: landscape) and (max-height: 500px) {
            #game-container {
                flex-direction: row;
                justify-content: space-around;
                aspect-ratio: 1.8 / 1;
                width: 98vw;
                height: 95vh;
                padding: 15px;
            }
            #header {
                flex-direction: column;
                align-items: center;
                margin-bottom: 0;
                margin-right: 15px;
                padding: 0;
            }
            #game-area {
                flex-direction: row;
                gap: 15px;
                flex-grow: 1;
                max-width: 60%;
            }
            #game-grid {
                flex-shrink: 0;
            }
            #block-preview {
                flex-direction: column;
                padding: 10px;
                min-height: unset;
                min-width: 100px;
                height: auto;
                width: auto;
                flex-grow: 1;
                justify-content: space-around;
                overflow-y: auto;
                align-items: center;
                flex-wrap: nowrap;
                 gap: 10px;
            }
            .block-slot {
                width: var(--block-slot-dynamic-size, 80px);
                height: var(--block-slot-dynamic-size, 80px);
            }
        }

        #header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 0 10px;
            color: #FFFFFF;
            position: relative;
            z-index: 2;
        }

        #header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #menu-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #menu-button .icon {
            width: clamp(1.2em, 4.5vw, 2em);
            height: clamp(1.2em, 4.5vw, 2em);
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24" fill="%23FFFFFF"><path d="M120-240v-80h720v80H120Zm0-200v-80h720v80H120Zm0-200v-80h720v80H120Z"/></svg>');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        #game-title {
            font-size: 2.8em;
            color: #FFFFFF;
            text-shadow: none;
            margin: 0;
            white-space: nowrap;
            font-size: clamp(1.1em, 4.5vw, 2.2em);
            font-family: 'Bangers', cursive;
        }
        /* Specific color classes for UVOBLOCK title */
        .color-u { color: #FF0000; } /* Red */
        .color-v { color: #FFA500; } /* Orange */
        .color-o1 { color: #FFFF00; } /* Yellow */
        .color-b { color: #00FF00; } /* Green */
        .color-l { color: #0000FF; } /* Blue */
        .color-o2 { color: #800080; } /* Purple */
        .color-c { color: #A52A2A; } /* Brown */
        .color-k { color: #FFFFFF; } /* White */

        #score-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            margin-top: 10px;
        }
        #crown-score-wrapper {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #crown-icon {
            width: clamp(1em, 3.5vw, 1.5em);
            height: clamp(1em, 3.5vw, 1.5em);
            filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.5));
            background-image: url('https://raw.githubusercontent.com/google/material-design-icons/master/png/social/crown_FILL0_wght400_GRAD0_opsz24.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        #scoreDisplay {
            font-size: 1.8em;
            color: #FFFFFF;
            text-shadow: none;
            margin: 0;
            white-space: nowrap;
            font-size: clamp(0.9em, 3.5vw, 1.6em);
        }

        #game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            flex-grow: 1;
            justify-content: center;
            width: 100%;
        }

        #game-grid {
            display: grid;
            border: none;
            background-color: #1A3E72;
            box-shadow: none;
            border-radius: 5px;
            overflow: hidden;
            aspect-ratio: 1 / 1;
        }

        .grid-cell {
            border: 1px solid rgba(0, 0, 0, 0.1);
            background-color: #1F4C86;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.1s ease-out;
            font-size: 0;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            position: relative;
        }

        /* Block Textures for Grid Cells (Full Size) */
        .grid-cell.texture-gold {
            background-image: url('https://i.imgur.com/your-gold-texture-image.png'); /* Replace with actual gold texture */
            background-color: #F1C40F;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
        }
        .grid-cell.texture-blue-block {
            background-image: url('https://i.imgur.com/your-blue-texture-image.png'); /* Replace with actual blue texture */
            background-color: #3498DB;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
        }

        #block-preview {
            display: flex;
            gap: 15px;
            padding: 10px;
            background-color: transparent;
            border-radius: 10px;
            align-items: center;
            justify-content: space-around;
            width: 100%;
            flex-wrap: nowrap;
            overflow: visible;
            min-height: var(--block-slot-dynamic-size);
        }

        .block-slot {
            width: var(--block-slot-dynamic-size, 80px);
            height: var(--block-slot-dynamic-size, 80px);
            border: none;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 5px;
            cursor: grab;
            transition: transform 0.1s ease-out, opacity 0.1s ease-out;
            background-color: transparent;
            flex-shrink: 1;
            flex-grow: 0;
            flex-basis: auto;
            touch-action: none;
        }

        /* Styling for EMPTY block slots */
        .block-slot.empty {
            border: 1px dashed rgba(255, 255, 255, 0.2); /* A subtle border for empty slots */
            background-color: rgba(0, 0, 0, 0.1); /* Slight background for empty slots */
            cursor: default;
            pointer-events: none; /* Crucial: no interaction on empty slots */
        }

        .block-slot:hover:not(.dragging):not(.empty) { /* Only hover if not dragging and not empty */
            transform: translateY(-3px);
        }
        .block-slot.dragging {
            cursor: grabbing;
            transform: scale(1.03);
            opacity: 0.5;
        }

        .draggable-block-container {
            display: grid;
            grid-auto-rows: var(--block-piece-dynamic-size);
            pointer-events: none; /* Block container itself shouldn't capture events */
        }

        .block-piece {
            width: var(--block-piece-dynamic-size);
            height: var(--block-piece-dynamic-size);
            border: none;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            display: flex;
            justify-content: center;
            align-items: center;
            color: rgba(255,255,255,0.7);
        }

        /* Block Textures for Preview Pieces (Smaller Size) */
        .block-piece.texture-gold {
            background-image: url('https://i.imgur.com/your-gold-texture-image-small.png');
            background-color: #F1C40F;
            border-radius: 3px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .block-piece.texture-blue-block {
            background-image: url('https://i.imgur.com/your-blue-texture-image-small.png');
            background-color: #3498DB;
            border-radius: 3px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .ghost {
            opacity: 0.8;
            position: fixed;
            z-index: 9999;
            transition: opacity 0.1s ease-out;
            pointer-events: none;
        }

        .grid-cell.highlight {
            background-color: rgba(46, 204, 113, 0.4) !important;
            border: 2px solid #2ecc71;
            box-shadow: 0 0 8px rgba(46, 204, 113, 0.8);
        }

        .grid-cell.invalid {
            background-color: rgba(231, 76, 60, 0.4) !important;
            border: 2px solid #e74c3c;
            box-shadow: 0 0 8px rgba(231, 76, 60, 0.8);
        }

        .grid-cell.destroying {
            animation: satisfyingDestroy 0.4s forwards ease-out;
        }

        @keyframes satisfyingDestroy {
            0% { transform: scale(1) rotate(0deg); opacity: 1; }
            50% { transform: scale(1.2) rotate(5deg) translateY(-3px); opacity: 0.7; filter: brightness(1.2); }
            100% { transform: scale(0.1) rotate(-20deg) translateY(5px); opacity: 0; filter: brightness(0.5); }
        }

        #game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ecf0f1;
            text-align: center;
            z-index: 100;
            border-radius: inherit;
            transition: opacity 0.3s ease-out;
        }

        #game-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #overlay-message {
            font-size: clamp(1.8em, 7vw, 2.8em);
            color: #e74c3c;
            margin-bottom: 25px;
            text-shadow: 0 0 18px #e74c3c, 0 0 8px #e74c3c;
        }

        #finalScoreDisplay {
            font-size: clamp(1.2em, 5vw, 1.5em);
            color: #f1c40f;
            margin-bottom: 25px;
        }

        #restartButton {
            padding: 15px 35px;
            font-size: clamp(1.1em, 5vw, 1.5em);
            background-color: #2ecc71;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        #restartButton:hover {
            background-color: #27ae60;
            transform: translateY(-2px);
        }

        #restartButton:active {
            background-color: #219d54;
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* Sidebar Menu Styles */
        #sidebar-menu {
            position: fixed;
            top: 0;
            left: -300px; /* Hidden by default */
            width: 250px;
            max-width: 80vw; /* Prevent it from being too wide on small screens */
            height: 100%;
            background-color: #2c3e50; /* Darker blue-grey */
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.5);
            transition: left 0.3s ease-in-out;
            z-index: 102; /* Above game-container and overlay */
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
            color: #ecf0f1;
        }

        #sidebar-menu.open {
            left: 0;
        }

        #sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        #sidebar-header h2 {
            font-size: clamp(1.2em, 5vw, 2em); /* Smaller font for header */
            color: #f1c40f;
            font-family: 'Bangers', cursive;
            margin: 0;
            white-space: nowrap; /* Prevent wrapping for smaller fonts */
        }

        #close-sidebar-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #close-sidebar-button .icon {
            width: clamp(1.2em, 4.5vw, 2em);
            height: clamp(1.2em, 4.5vw, 2em);
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24" fill="%23FFFFFF"><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg>');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .menu-item {
            padding: 12px 15px; /* Slightly reduced padding */
            margin-bottom: 8px; /* Slightly reduced margin */
            background-color: #34495e;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            font-size: clamp(0.7em, 3.5vw, 1em); /* Smaller font for menu items */
            text-align: left;
            display: flex;
            align-items: center;
            gap: 8px; /* Slightly reduced gap */
            white-space: nowrap; /* Prevent wrapping */
        }

        .menu-item:hover {
            background-color: #3b536b;
        }

        .menu-item .icon {
            width: 1.3em; /* Slightly smaller icon */
            height: 1.3em;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            filter: invert(100%);
        }

        #menu-redeem-section {
            margin-top: 15px; /* Reduced margin-top */
            border-top: 1px solid rgba(255,255,255,0.1);
            padding-top: 15px; /* Reduced padding-top */
            display: none; /* Hidden by default */
            flex-direction: column; /* Ensure it stacks correctly when visible */
            gap: 10px; /* Gap between input and button */
        }

        #menu-redeem-section input {
            width: 100%;
            padding: 8px; /* Reduced padding */
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: #ecf0f1;
            color: #333;
            font-size: clamp(0.7em, 3vw, 1em); /* Smaller font */
            text-align: center;
            box-sizing: border-box; /* Include padding in width */
        }

        #menu-redeem-section button {
            width: 100%;
            padding: 10px 20px; /* Reduced padding */
            font-size: clamp(0.8em, 3.5vw, 1.1em); /* Smaller font */
            background-color: #9b59b6;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            box-sizing: border-box; /* Include padding in width */
        }
        #menu-redeem-section button:hover {
            background-color: #8e44ad;
        }

        #redeem-message {
            font-size: clamp(0.65em, 2.8vw, 0.9em); /* Smaller font */
            margin-top: 5px;
            color: #f1c40f;
            text-align: center;
        }

        #version-info {
            font-size: clamp(0.6em, 2.5vw, 0.8em); /* Even smaller font for version info */
            color: #bdc3c7;
            margin-top: 15px; /* Reduced margin-top */
            text-align: center;
            border-top: 1px solid rgba(255,255,255,0.1);
            padding-top: 10px; /* Reduced padding-top */
        }
        #version-info p {
            margin-bottom: 4px; /* Reduced margin-bottom */
        }
        #version-info a {
            font-size: clamp(0.6em, 2.5vw, 0.8em); /* Match parent font size */
        }


        /* Overlay for menu background */
        #menu-overlay-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 101; /* Behind sidebar, above game */
            display: none; /* Hidden by default */
        }
        #menu-overlay-bg.visible {
            display: block;
        }

    </style>
</head>
<body>
    <div id="game-container">
        <div id="header">
            <div id="header-left">
                <button id="menu-button"><span class="icon"></span></button>
            </div>
            <div id="score-container">
                <h1 id="game-title">
                    <span class="color-u">U</span><span class="color-v">V</span><span class="color-o1">O</span><span class="color-b">B</span><span class="color-l">L</span><span class="color-o2">O</span><span class="color-c">C</span><span class="color-k">K</span>
                </h1>
                <div id="crown-score-wrapper">
                    <span id="crown-icon"></span>
                    <div id="scoreDisplay">0</div>
                </div>
            </div>
            <div id="header-right">
                </div>
        </div>

        <div id="game-area">
            <div id="game-grid"></div>
            <div id="block-preview"></div>
        </div>

        <div id="game-overlay" class="hidden">
            <div id="overlay-message"></div>
            <div id="finalScoreDisplay"></div>
            <button id="restartButton">Mulai Ulang</button>
        </div>
    </div>

    <div id="sidebar-menu">
        <div id="sidebar-header">
            <h2>Menu</h2>
            <button id="close-sidebar-button"><span class="icon"></span></button>
        </div>

        <div class="menu-item" id="resetScoreMenuItem">
            <span class="icon" style="background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24" fill="%23FFFFFF"><path d="M480-160q-134 0-227-93t-93-227q0-134 93-227t227-93q69 0 132 28.5t109 75.5q32-32 68.5-49t75.5-17h-117l-156 160h400v-400L794-670q-47-47-109-75.5T480-770q-134 0-227 93t-93 227q0 134 93 227t227 93Z"/></svg>');"></span>
            Reset Skor
        </div>
        <div class="menu-item" id="redeemCodeMenuItem">
            <span class="icon" style="background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24" fill="%23FFFFFF"><path d="M220-160q-24 0-42-18t-18-42v-520q0-24 18-42t42-18h520q24 0 42 18t18 42v520q0 24-18 42t-42 18H220Zm0-80h520V240H220v520Zm0 0V240v520Zm40-270q-17 0-28.5-11.5T220-540q0-17 11.5-28.5T260-580q17 0 28.5 11.5T300-540q0 17-11.5 28.5T260-500Zm400 0q-17 0-28.5-11.5T620-540q0-17 11.5-28.5T660-580q17 0 28.5 11.5T700-540q0 17-11.5 28.5T660-500Zm-200 0q-17 0-28.5-11.5T420-540q0-17 11.5-28.5T460-580q17 0 28.5 11.5T500-540q0 17-11.5 28.5T460-500Zm-200 200q-17 0-28.5-11.5T220-340q0-17 11.5-28.5T260-380q17 0 28.5 11.5T300-340q0 17-11.5 28.5T260-300Zm400 0q-17 0-28.5-11.5T620-340q0-17 11.5-28.5T660-380q17 0 28.5 11.5T700-340q0 17-11.5 28.5T660-300Zm-200 0q-17 0-28.5-11.5T420-340q0-17 11.5-28.5T460-380q17 0 28.5 11.5T500-340q0 17-11.5 28.5T460-300ZM220-760v520-520Z"/></svg>');"></span>
            Redeem Kode
        </div>
        <div id="menu-redeem-section">
            <input type="text" id="redeemInput" placeholder="Masukkan kode redeem" maxlength="5">
            <button id="redeemButton">Redeem</button>
            <div id="redeem-message"></div>
        </div>
        <div class="menu-item" id="backToHomeMenuItem">
            <span class="icon" style="background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24" fill="%23FFFFFF"><path d="M240-200h120v-240h240v240h120v-360L480-740 240-560v360Zm-80 80v-480l320-240 320 240v480H520v-240H440v240H160Zm320-350Z"/></svg>');"></span>
            Kembali ke Halaman Utama
        </div>

        <div id="version-info">
            <p>UVOBLOCK v 1.3</p>
            <p>by ADITdeveloper</p>
            <a href="https://wa.me/6285648211278" target="_blank" style="color: #25D366; text-decoration: none; display: block; margin-top: 10px;">Beli Paket</a>
        </div>
    </div>
    <div id="menu-overlay-bg"></div>

<script>
    const gameGrid = document.getElementById('game-grid');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const blockPreview = document.getElementById('block-preview');
    const gameOverlay = document.getElementById('game-overlay');
    const overlayMessage = document.getElementById('overlay-message');
    const finalScoreDisplay = document.getElementById('finalScoreDisplay');
    const restartButton = document.getElementById('restartButton');

    // Menu elements
    const menuButton = document.getElementById('menu-button');
    const sidebarMenu = document.getElementById('sidebar-menu');
    const closeSidebarButton = document.getElementById('close-sidebar-button');
    const menuOverlayBg = document.getElementById('menu-overlay-bg');
    const resetScoreMenuItem = document.getElementById('resetScoreMenuItem');
    const redeemCodeMenuItem = document.getElementById('redeemCodeMenuItem');
    const menuRedeemSection = document.getElementById('menu-redeem-section');
    const redeemInput = document.getElementById('redeemInput');
    const redeemButton = document.getElementById('redeemButton');
    const redeemMessage = document.getElementById('redeem-message');
    const backToHomeMenuItem = document.getElementById('backToHomeMenuItem');

    const GRID_SIZE = 9;
    const GRID_CELL_COLOR = '#1F4C86';
    const OCCUPIED_COLOR_BASE = '#3498DB'; // Base color for blue blocks
    const GOLD_COLOR_BASE = '#F1C40F'; // Base color for gold blocks

    let grid = [];
    let score = 0;
    let combo = 0; // Current combo streak (not used for currentCombo in placement)
    let currentCombo = 0; // For tracking combo within a single block placement
    let multiplier = 1; // Score multiplier
    let extraMoves = 0; // For extra moves power-up
    let hintAvailable = false; // For hint power-up
    let blockDestroyerAvailable = false; // For block destroyer item
    let rareItemAvailable = false; // For rare item effect (placeholder)

    // Block shapes (now includes 'type' for texture)
    const BLOCK_SHAPES = [
        // Type 'blue-block'
        { id: '1x1-blue', shape: [[1]], type: 'blue-block' },
        { id: '1x2-blue', shape: [[1],[1]], type: 'blue-block' },
        { id: '2x1-blue', shape: [[1,1]], type: 'blue-block' },
        { id: '1x3-blue', shape: [[1],[1],[1]], type: 'blue-block' },
        { id: '3x1-blue', shape: [[1,1,1]], type: 'blue-block' },
        { id: '2x2-blue', shape: [[1,1],[1,1]], type: 'blue-block' },
        { id: 'L-small-blue', shape: [[1,0],[1,1]], type: 'blue-block' },
        { id: 'L-small-rotated-blue', shape: [[1,1],[1,0]], type: 'blue-block' },
        { id: 'T-small-blue', shape: [[1,1,1],[0,1,0]], type: 'blue-block' },
        { id: 'cross-blue', shape: [[0,1,0],[1,1,1],[0,1,0]], type: 'blue-block' },
        // Type 'gold' (example) - these might be rarer or have special properties
        { id: '1x1-gold', shape: [[1]], type: 'gold' },
        { id: '2x2-gold', shape: [[1,1],[1,1]], type: 'gold' },
        { id: 'Z-gold', shape: [[1,1,0],[0,1,1]], type: 'gold' },
    ];

    // Redeem Codes
    const REDEEM_CODES = {
        "19482": { type: "score", value: 500 },
        "82714": { type: "score", value: 300, bonus: "combo_booster" },
        "56390": { type: "score", value: 1000 },
        "30915": { type: "score", value: 200, bonus: "multiplier", value_multiplier: 2 },
        "74826": { type: "score", value: 750, bonus: "rare_item" },
        "15239": { type: "score", value: 450, bonus: "hint_free" },
        "93407": { type: "score", value: 600, bonus: "double_combo" },
        "62891": { type: "score", value: 800 },
        "47520": { type: "score", value: 550, bonus: "extra_move" },
        "31067": { type: "score", value: 900, bonus: "block_destroyer" },
        // New Redeem Codes
        "55555": { type: "score", value: 5000 },
        "12345": { type: "score", value: 1000 },
        "12121": { type: "score", value: 500 },
        "98765": { type: "score", value: 2000 }
    };

    let currentBlocks = [];
    let draggedBlock = null;
    let draggedBlockIndex = -1;
    let ghostBlockElements = [];
    let blockTextures = {
        'blue-block': 'https://i.imgur.com/your-blue-texture-image.png', // Replace with actual blue block texture
        'gold': 'https://i.imgur.com/your-gold-texture-image.png' // Replace with actual gold block texture
    };
    let blockPieceTextures = {
        'blue-block': 'https://i.imgur.com/your-blue-texture-image-small.png', // Replace with actual small blue block texture
        'gold': 'https://i.imgur.com/your-gold-texture-image-small.png' // Replace with actual small gold block texture
    };


    function initializeGame() {
        score = loadScore();
        updateScoreDisplay();
        createGrid();
        fillBlockPreview();
        hideOverlay();
        // Ensure sidebar is closed when game initializes/restarts
        sidebarMenu.classList.remove('open');
        menuOverlayBg.classList.remove('visible');
        menuRedeemSection.style.display = 'none'; // Hide redeem input
    }

    function createGrid() {
        gameGrid.innerHTML = '';
        gameGrid.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
        grid = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));

        // Dynamically set cell size based on container width
        // This will be overridden by setDynamicSizes, but good to have a default
        const containerWidth = gameGrid.offsetWidth;
        const cellSize = containerWidth / GRID_SIZE;
        gameGrid.style.gridAutoRows = `${cellSize}px`;

        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                const cell = document.createElement('div');
                cell.classList.add('grid-cell');
                cell.dataset.row = r;
                cell.dataset.col = c;
                gameGrid.appendChild(cell);
            }
        }
        updateGridDisplay();
    }

    function updateGridDisplay() {
        const cells = gameGrid.children;
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                const index = r * GRID_SIZE + c;
                const cell = cells[index];
                cell.classList.remove('occupied', 'texture-blue-block', 'texture-gold', 'destroying'); // Ensure destroying class is removed
                cell.style.backgroundImage = ''; // Clear any inline styles from previous states

                if (grid[r][c] === 1) {
                    cell.classList.add('occupied', 'texture-blue-block');
                    cell.style.backgroundColor = ''; // Let CSS class handle background-color
                } else if (grid[r][c] === 2) { // Example for a different block type like gold
                    cell.classList.add('occupied', 'texture-gold');
                    cell.style.backgroundColor = '';
                } else {
                    cell.style.backgroundColor = GRID_CELL_COLOR; // Set default background for empty cells
                }
                // Ensure border remains, as this was a reported stability issue
                cell.style.border = '1px solid rgba(0, 0, 0, 0.1)';
            }
        }
    }


    function getRandomBlock() {
        const randomIndex = Math.floor(Math.random() * BLOCK_SHAPES.length);
        return JSON.parse(JSON.stringify(BLOCK_SHAPES[randomIndex])); // Deep copy to prevent modification
    }

    function fillBlockPreview() {
        // Filter out any null blocks (blocks that have been successfully placed)
        currentBlocks = currentBlocks.filter(block => block !== null);
        while (currentBlocks.length < 3) {
            currentBlocks.push(getRandomBlock());
        }
        drawBlockPreview();
    }

    function drawBlockPreview() {
    blockPreview.innerHTML = '';
    currentBlocks.forEach((block, index) => {
        const slot = document.createElement('div');
        slot.classList.add('block-slot');
        slot.dataset.index = index;

        if (block) {
            slot.addEventListener('mousedown', dragStart);
            slot.addEventListener('touchstart', dragStart, { passive: false });

            const blockContainer = document.createElement('div');
            blockContainer.classList.add('draggable-block-container');
            blockContainer.style.gridTemplateColumns = `repeat(${block.shape[0].length}, 1fr)`;

            block.shape.forEach(row => {
                row.forEach(cell => {
                    const piece = document.createElement('div');
                    if (cell === 1) {
                        piece.classList.add('block-piece');
                        piece.classList.add(`texture-${block.type}`);
                        piece.style.backgroundImage = `url('${blockPieceTextures[block.type]}')`;
                        piece.style.backgroundColor = block.type === 'gold' ? GOLD_COLOR_BASE : OCCUPIED_COLOR_BASE;
                        blockContainer.appendChild(piece);
                    }
                });
            });
            slot.appendChild(blockContainer);
        } else {
            // ✅ Slot kosong
            slot.classList.add('empty');
        }
        blockPreview.appendChild(slot);
    });

    checkGameOver(); // Always check game over after redrawing blocks
    }

    function canPlaceBlock(block, startRow, startCol) {
        if (!block) return false;
        const shape = block.shape;
        for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[r].length; c++) {
                if (shape[r][c] === 1) {
                    const gridRow = startRow + r;
                    const gridCol = startCol + c;
                    // Check bounds and if target cell is already occupied
                    if (gridRow < 0 || gridRow >= GRID_SIZE || gridCol < 0 || gridCol >= GRID_SIZE || grid[gridRow][gridCol] !== 0) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    function placeBlock(block, startRow, startCol) {
    // ✅ Blok tidak valid kalau bukan dari currentBlocks atau sudah null
    const blockIndex = currentBlocks.indexOf(block);
    if (blockIndex === -1 || currentBlocks[blockIndex] === null) return false;

    if (!canPlaceBlock(block, startRow, startCol)) {
        return false;
    }

    const shape = block.shape;
    for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
            if (shape[r][c] === 1) {
                grid[startRow + r][startCol + c] = block.type === 'gold' ? 2 : 1;
            }
        }
    }

    addScore(shape.flat().filter(cell => cell === 1).length * multiplier);

    // ✅ Tandai blok sudah dipakai satu kali
    currentBlocks[blockIndex] = null;
    return true; // Add score for placed pieces
        return true;
    }

    function highlightCells(block, startRow, startCol, isValid) {
        removeHighlights();
        const cells = gameGrid.children;
        const shape = block.shape;
        ghostBlockElements = [];

        for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[r].length; c++) {
                if (shape[r][c] === 1) {
                    const gridRow = startRow + r;
                    const gridCol = startCol + c;
                    const index = gridRow * GRID_SIZE + gridCol;

                    if (gridRow >= 0 && gridRow < GRID_SIZE && gridCol >= 0 && gridCol < GRID_SIZE) {
                        const cell = cells[index];
                        if (isValid) {
                            cell.classList.add('highlight');
                        } else {
                            cell.classList.add('invalid');
                        }
                        ghostBlockElements.push(cell); // Keep track of highlighted cells
                    }
                }
            }
        }
    }

    function removeHighlights() {
        ghostBlockElements.forEach(cell => {
            cell.classList.remove('highlight', 'invalid');
        });
        ghostBlockElements = [];
    }

    function clearLines() {
        let linesCleared = 0;
        let cellsCleared = 0;
        const cellsToAnimate = new Set();

        // Check rows
        for (let r = 0; r < GRID_SIZE; r++) {
            if (grid[r].every(cell => cell !== 0)) {
                linesCleared++;
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (!cellsToAnimate.has(`${r}-${c}`)) {
                        cellsToAnimate.add(`${r}-${c}`);
                        const index = r * GRID_SIZE + c;
                        gameGrid.children[index].classList.add('destroying');
                    }
                }
                // Don't clear immediately, wait for animation
            }
        }

        // Check columns
        for (let c = 0; c < GRID_SIZE; c++) {
            let columnFull = true;
            for (let r = 0; r < GRID_SIZE; r++) {
                if (grid[r][c] === 0) {
                    columnFull = false;
                    break;
                }
            }
            if (columnFull) {
                linesCleared++;
                for (let r = 0; r < GRID_SIZE; r++) {
                     if (!cellsToAnimate.has(`${r}-${c}`)) {
                        cellsToAnimate.add(`${r}-${c}`);
                        const index = r * GRID_SIZE + c;
                        gameGrid.children[index].classList.add('destroying');
                    }
                }
                // Don't clear immediately, wait for animation
            }
        }

        cellsCleared = cellsToAnimate.size; // Count how many unique cells are to be cleared

        if (linesCleared > 0) {
            currentCombo++;
            addScore(cellsCleared * 10 * multiplier); // Score for cleared cells
            if (currentCombo > 1) {
                addScore(currentCombo * 50 * multiplier); // Combo bonus
                displayFloatingText(`Combo x${currentCombo}!`, 'combo-text');
            }

            // Perform the actual grid clearing after animation is applied
            setTimeout(() => {
                // Clear rows
                for (let r = 0; r < GRID_SIZE; r++) {
                    if (grid[r].every(cell => cell !== 0)) { // Re-check if row is still full (can happen if grid changed during animation)
                        grid[r].fill(0);
                    }
                }
                // Clear columns
                for (let c = 0; c < GRID_SIZE; c++) {
                    let columnFullAfterRows = true;
                    for (let r = 0; r < GRID_SIZE; r++) {
                        if (grid[r][c] === 0) {
                            columnFullAfterRows = false;
                            break;
                        }
                    }
                    if (columnFullAfterRows) {
                        for (let r = 0; r < GRID_SIZE; r++) {
                            grid[r][c] = 0;
                        }
                    }
                }
                updateGridDisplay(); // Update after animation
                fillBlockPreview(); // Generate new blocks if needed
            }, 400); // Match animation duration
        } else {
            currentCombo = 0; // Reset combo if no lines cleared
            fillBlockPreview(); // Generate new blocks immediately if no lines cleared
        }
    }

    function addScore(points) {
        score += points;
        updateScoreDisplay();
        saveScore();
    }

    function updateScoreDisplay() {
        scoreDisplay.textContent = score;
    }

    function displayFloatingText(text, className) {
        const floatingText = document.createElement('div');
        floatingText.textContent = text;
        floatingText.classList.add('floating-text', className);
        document.body.appendChild(floatingText);

        const scoreRect = scoreDisplay.getBoundingClientRect();
        floatingText.style.left = `${scoreRect.left + scoreRect.width / 2}px`;
        floatingText.style.top = `${scoreRect.top + scoreRect.height / 2}px`;

        // Trigger animation
        floatingText.offsetHeight; // Trigger reflow
        floatingText.classList.add('show');

        floatingText.addEventListener('animationend', () => {
            floatingText.remove();
        });
    }

    function checkGameOver() {
        let anyBlockCanBePlaced = false;
        for (const block of currentBlocks) {
            if (!block) continue; // Skip null slots (already used blocks)
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (canPlaceBlock(block, r, c)) {
                        anyBlockCanBePlaced = true;
                        break;
                    }
                }
                if (anyBlockCanBePlaced) break;
            }
            if (anyBlockCanBePlaced) break;
        }

        // Game over if no blocks can be placed AND there are still blocks in preview (not null)
        if (!anyBlockCanBePlaced && currentBlocks.some(block => block !== null)) {
            showGameOver();
        } else if (currentBlocks.every(block => block === null)) {
            // If all blocks are used, generate new ones immediately (this ensures continuous play)
            fillBlockPreview();
        }
    }

    function showGameOver() {
        overlayMessage.textContent = 'GAME OVER!';
        finalScoreDisplay.textContent = `Skor Akhir: ${score}`;
        gameOverlay.classList.remove('hidden');
    }

    function hideOverlay() {
        gameOverlay.classList.add('hidden');
    }

    restartButton.addEventListener('click', () => {
        score = 0;
        multiplier = 1;
        extraMoves = 0;
        hintAvailable = false;
        blockDestroyerAvailable = false;
        rareItemAvailable = false;
        saveScore();
        initializeGame();
    });

    // Drag and Drop Logic
    function dragStart(e) {
    if (e.button !== 0 && e.type !== 'touchstart') return;

    const slot = e.currentTarget;
    draggedBlockIndex = parseInt(slot.dataset.index);
    draggedBlock = currentBlocks[draggedBlockIndex];

    if (!draggedBlock) return; // ✅ Cegah drag jika blok sudah digunakan


        if (!draggedBlock) return; // If slot is empty (null block), do nothing

        slot.classList.add('dragging');

        // Create a ghost element for dragging
        const ghost = document.createElement('div');
        ghost.classList.add('ghost');
        const blockContainer = document.createElement('div');
        blockContainer.classList.add('draggable-block-container');
        blockContainer.style.gridTemplateColumns = `repeat(${draggedBlock.shape[0].length}, 1fr)`;

        draggedBlock.shape.forEach(row => {
            row.forEach(cell => {
                const piece = document.createElement('div');
                if (cell === 1) {
                    piece.classList.add('block-piece');
                    piece.classList.add(`texture-${draggedBlock.type}`);
                    piece.style.backgroundImage = `url('${blockPieceTextures[draggedBlock.type]}')`;
                    piece.style.backgroundColor = draggedBlock.type === 'gold' ? GOLD_COLOR_BASE : OCCUPIED_COLOR_BASE;
                }
                blockContainer.appendChild(piece);
            });
        });
        ghost.appendChild(blockContainer);
        document.body.appendChild(ghost);


        function moveGhost(clientX, clientY) {
            ghost.style.left = `${clientX - ghost.offsetWidth / 2}px`;
            ghost.style.top = `${clientY - ghost.offsetHeight / 2}px`;

            const targetCell = getTargetGridCell(clientX, clientY);
            if (targetCell) {
                const targetCellInfo = targetCell.dataset;
                const blockRows = draggedBlock.shape.length;
                const blockCols = draggedBlock.shape[0].length;
                // Calculate startRow/startCol based on center of block over target cell
                const startRow = parseInt(targetCellInfo.row) - Math.floor(blockRows / 2);
                const startCol = parseInt(targetCellInfo.col) - Math.floor(blockCols / 2);
                const isValid = canPlaceBlock(draggedBlock, startRow, startCol);
                highlightCells(draggedBlock, startRow, startCol, isValid);
            } else {
                removeHighlights();
            }
        }

        // Initial ghost position
        const initialClientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
        const initialClientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
        moveGhost(initialClientX, initialClientY);

        function drag(e) {
            e.preventDefault(); // Prevent scrolling on touch
            const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
            const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
            moveGhost(clientX, clientY);
        }

        function dragEnd(e) {
            slot.classList.remove('dragging');
            if (ghost.parentNode) {
                ghost.remove();
            }
            removeHighlights();

            const clientX = e.type === 'touchend' ? e.changedTouches[0].clientX : e.clientX;
            const clientY = e.type === 'touchend' ? e.changedTouches[0].clientY : e.clientY;

            const targetCell = getTargetGridCell(clientX, clientY);
            let blockPlacedSuccessfully = false;

            if (targetCell) {
                const targetCellInfo = targetCell.dataset;
                const blockRows = draggedBlock.shape.length;
                const blockCols = draggedBlock.shape[0].length;
                const startRow = parseInt(targetCellInfo.row) - Math.floor(blockRows / 2);
                const startCol = parseInt(targetCellInfo.col) - Math.floor(blockCols / 2);

                if (canPlaceBlock(draggedBlock, startRow, startCol)) {
                    if (placeBlock(draggedBlock, startRow, startCol)) {
                        currentBlocks[draggedBlockIndex] = null; // Mark the block as used (THIS IS THE KEY LINE)
                        blockPlacedSuccessfully = true;
                        updateGridDisplay();
                        clearLines(); // clearLines will eventually call fillBlockPreview/drawBlockPreview
                    }
                }
            }

            if (!blockPlacedSuccessfully) {
                currentCombo = 0; // Reset combo if block not placed
                // The block remains in currentBlocks, just redraw to reset its position
                drawBlockPreview();
                checkGameOver();
            }
            // If block was placed, currentBlocks[draggedBlockIndex] is null, and clearLines() will trigger fillBlockPreview.
            // If no lines cleared, fillBlockPreview is called directly.

            removeDragListeners();
            draggedBlock = null;
            draggedBlockIndex = -1;
        }

        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', dragEnd);
        document.addEventListener('touchmove', drag, { passive: false });
        document.addEventListener('touchend', dragEnd);
        document.addEventListener('touchcancel', dragEnd);
    }

    function getTargetGridCell(clientX, clientY) {
        const elements = document.elementsFromPoint(clientX, clientY);
        for (const el of elements) {
            if (el.classList.contains('grid-cell')) {
                return el;
            }
        }
        return null;
    }

    function removeDragListeners() {
        document.removeEventListener('mousemove', drag);
        document.removeEventListener('mouseup', dragEnd);
        document.removeEventListener('touchmove', drag);
        document.removeEventListener('touchend', dragEnd);
        document.removeEventListener('touchcancel', dragEnd);
    }

    // Local Storage functions
    function saveScore() {
        localStorage.setItem('uvoblockScore', score);
    }

    function loadScore() {
        const savedScore = localStorage.getItem('uvoblockScore');
        return savedScore ? parseInt(savedScore) : 0;
    }

    // Sidebar Menu functionality
    menuButton.addEventListener('click', () => {
        sidebarMenu.classList.add('open');
        menuOverlayBg.classList.add('visible');
    });

    closeSidebarButton.addEventListener('click', () => {
        sidebarMenu.classList.remove('open');
        menuOverlayBg.classList.remove('visible');
        menuRedeemSection.style.display = 'none'; // Hide redeem input when closing
        redeemMessage.textContent = ''; // Clear message on close
        redeemInput.value = ''; // Clear input on close
    });

    menuOverlayBg.addEventListener('click', () => {
        sidebarMenu.classList.remove('open');
        menuOverlayBg.classList.remove('visible');
        menuRedeemSection.style.display = 'none'; // Hide redeem input when clicking outside
        redeemMessage.textContent = ''; // Clear message on close
        redeemInput.value = ''; // Clear input on close
    });

    // Reset Score functionality
    resetScoreMenuItem.addEventListener('click', () => {
        if (confirm('Apakah Anda yakin ingin mereset skor Anda? Ini tidak dapat dibatalkan.')) {
            score = 0;
            multiplier = 1;
            extraMoves = 0;
            hintAvailable = false;
            blockDestroyerAvailable = false;
            rareItemAvailable = false;
            saveScore(); // Save the reset score
            updateScoreDisplay(); // Update display
            // Clear all redeemed codes on full reset
            Object.keys(REDEEM_CODES).forEach(code => localStorage.removeItem(`redeemed_${code}`));
            redeemMessage.textContent = 'Skor dan kode redeem berhasil direset!';
            redeemMessage.style.color = '#2ecc71';
            // Close sidebar after action
            sidebarMenu.classList.remove('open');
            menuOverlayBg.classList.remove('visible');
            menuRedeemSection.style.display = 'none'; // Hide redeem input
            redeemInput.value = ''; // Clear input
            initializeGame(); // Re-initialize game to ensure UI matches reset state
        }
    });

    // Toggle Redeem Code input section
    redeemCodeMenuItem.addEventListener('click', () => {
        menuRedeemSection.style.display = menuRedeemSection.style.display === 'none' ? 'flex' : 'none';
        redeemMessage.textContent = ''; // Clear message when toggling
        redeemInput.value = ''; // Clear input when toggling
    });

    // Redeem code functionality (within sidebar)
    redeemButton.addEventListener('click', () => {
        const code = redeemInput.value.trim();
        if (code.length !== 5) { // Redeem codes are now 5 digits as per your provided list
            redeemMessage.textContent = 'Kode redeem harus 5 angka!';
            redeemMessage.style.color = '#e74c3c'; // Red for error
            return;
        }

        const reward = REDEEM_CODES[code];
        if (reward) {
            if (localStorage.getItem(`redeemed_${code}`)) {
                redeemMessage.textContent = 'Kode ini sudah digunakan!';
                redeemMessage.style.color = '#e74c3c'; // Red for error
                return;
            }

            score += reward.value;
            let message = `Redeem berhasil! Mendapat ${reward.value} skor!`;
            // Apply bonuses
            if (reward.bonus === "combo_booster") {
                combo += 3; // Example: Add 3 to combo, actual effect depends on implementation
                message += ' + Combo Booster!';
            }
            if (reward.bonus === "multiplier") {
                multiplier *= reward.value_multiplier;
                message += ` + ${reward.value_multiplier}x Multiplier!`;
            }
            if (reward.bonus === "rare_item") {
                rareItemAvailable = true;
                message += ' + 1 Item Rare!';
            }
            if (reward.bonus === "hint_free") {
                hintAvailable = true;
                message += ' + Hint Gratis!';
            }
            if (reward.bonus === "double_combo") {
                message += ' + Double Combo!';
            }
            if (reward.bonus === "extra_move") {
                extraMoves += 1;
                message += ' + Extra Move!';
            }
            if (reward.bonus === "block_destroyer") {
                blockDestroyerAvailable = true;
                message += ' + Block Destroyer Item!';
            }

            updateScoreDisplay();
            saveScore();
            localStorage.setItem(`redeemed_${code}`, 'true'); // Mark code as used
            redeemMessage.textContent = message;
            redeemMessage.style.color = '#2ecc71'; // Green for success
            redeemInput.value = ''; // Clear input
        } else {
            redeemMessage.textContent = 'Kode redeem tidak valid.';
            redeemMessage.style.color = '#e74c3c'; // Red for error
        }
    });

    // Back to Home functionality
    backToHomeMenuItem.addEventListener('click', () => {
        // You can replace this with your actual home page URL or a custom function
        window.location.href = 'index.html'; // Example: navigate to index.html
        // For local development, you might just want to reload or go back
        // window.history.back();
    });

    // Dynamic sizing for grid cells and block previews
    function setDynamicSizes() {
        const gameContainer = document.getElementById('game-container');
        let cellSize, blockSlotSize, blockPieceSize;

        // Ensure header element exists before trying to get its offsetHeight
        const headerElement = document.getElementById('header');
        const headerHeight = headerElement ? headerElement.offsetHeight : 0;

        if (window.matchMedia("(orientation: landscape) and (max-height: 500px)").matches) {
            // Landscape mode, adapt to height primarily
            const containerHeight = gameContainer.offsetHeight;
            cellSize = (containerHeight - headerHeight - 15) / GRID_SIZE; // Total height minus header and block preview gap
            blockSlotSize = (containerHeight - headerHeight - 15) / 3; // Approx 3 slots fitting vertically
            blockPieceSize = blockSlotSize / 5; // A piece is typically 1/3 or 1/5 of a block slot
        } else {
            // Portrait mode, adapt to width primarily
            const containerWidth = gameContainer.offsetWidth;
            const availableHeight = gameContainer.offsetHeight - headerHeight - 15; // Total height minus header and block preview gap
            cellSize = Math.min((containerWidth - 40) / GRID_SIZE, (availableHeight - 100) / GRID_SIZE); // 40 for padding, 100 for block preview area roughly
            blockSlotSize = (containerWidth - 40 - 30) / 3; // 40 for container padding, 30 for gap
            blockPieceSize = blockSlotSize / 5;
        }

        // Ensure minimum sensible sizes
        cellSize = Math.max(cellSize, 25);
        blockSlotSize = Math.max(blockSlotSize, 50);
        blockPieceSize = Math.max(blockPieceSize, 10);

        document.documentElement.style.setProperty('--grid-cell-dynamic-size', `${cellSize}px`);
        document.documentElement.style.setProperty('--block-slot-dynamic-size', `${blockSlotSize}px`);
        document.documentElement.style.setProperty('--block-piece-dynamic-size', `${blockPieceSize}px`);

        gameGrid.style.gridTemplateColumns = `repeat(${GRID_SIZE}, ${cellSize}px)`;
        gameGrid.style.gridAutoRows = `${cellSize}px`;

        drawBlockPreview(); // Redraw blocks with new sizes
        updateGridDisplay(); // Update grid cell background colors after resize
    }

    // Initial call and on resize
    window.addEventListener('resize', setDynamicSizes);
    document.addEventListener('DOMContentLoaded', () => {
        initializeGame();
        setDynamicSizes(); // Set sizes on initial load
    });

</script>
</body>
</html>